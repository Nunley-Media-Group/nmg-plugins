# File: .claude/specs/feature-retrospective-skill/feature.gherkin
#
# Consolidated from:
#   .claude/specs/1-spec-retrospective-skill/feature.gherkin (Issue #1)
#   .claude/specs/67-add-retrospective-state-tracking/feature.gherkin (Issue #67)

Feature: Spec Retrospective Skill
  As a developer using the nmg-sdlc workflow
  I want defect patterns to automatically feed back into how specs are written
  So that future specs avoid the same gaps that led to past bugs

  # --- Happy Path ---

  Scenario: Retrospective skill produces steering doc from defect specs
    Given defect specs exist in ".claude/specs/" with "Severity:" fields
    And at least one defect spec has a "Related Spec:" link to a feature spec
    And the linked feature spec exists at the referenced path
    When the user runs "/running-retrospectives"
    Then the skill reads each eligible defect spec and its linked feature spec
    And the skill identifies gaps between the feature spec coverage and the defect finding
    And each gap is classified as "Missing Acceptance Criteria", "Undertested Boundaries", or "Domain-Specific Gaps"
    And the skill creates ".claude/steering/retrospective.md" using the template
    And the retrospective doc contains a table entry for each learning with Source Defect, Related Feature Spec, and Recommendation columns
    And the skill outputs a summary showing defect specs analyzed and learnings generated

  # --- Integration ---

  Scenario: Writing-specs reads retrospective during Phase 1
    Given a ".claude/steering/retrospective.md" file exists with learnings
    And the learnings include "Authentication specs should include session timeout edge cases"
    When the user runs "/writing-specs" for a new feature spec
    Then Phase 1 reads ".claude/steering/retrospective.md"
    And relevant learnings are applied when drafting acceptance criteria
    And the generated requirements reflect domain-specific guidance from past defects

  # --- Empty State ---

  Scenario: Graceful handling when no defect specs exist
    Given no requirements.md files in ".claude/specs/" contain a "Severity:" field
    When the user runs "/running-retrospectives"
    Then the skill reports "No defect specs found"
    And no ".claude/steering/retrospective.md" file is created or modified

  Scenario: Graceful handling when defect specs lack Related Spec links
    Given defect specs exist in ".claude/specs/" with "Severity:" fields
    But none of the defect specs have a "Related Spec:" field
    When the user runs "/running-retrospectives"
    Then the skill reports "No defect specs with Related Spec links found"
    And no ".claude/steering/retrospective.md" file is created or modified

  # --- Filtering ---

  Scenario: Only spec-quality learnings are captured
    Given a defect spec exists caused by a missing acceptance criterion in the feature spec
    And a defect spec exists caused by an implementation typo
    And a defect spec exists caused by a CI misconfiguration
    And all three have "Related Spec:" links to feature specs
    When the user runs "/running-retrospectives"
    Then a learning is generated for the missing acceptance criterion defect
    And no learning is generated for the implementation typo defect
    And no learning is generated for the CI misconfiguration defect

  # --- Incremental Update ---

  Scenario: Retrospective doc is incrementally updated with new learnings
    Given a ".claude/steering/retrospective.md" exists with 3 learnings from a previous run
    And 2 new defect specs with "Related Spec:" links have been added since the last run
    And the 3 original defect specs still exist
    When the user runs "/running-retrospectives"
    Then the retrospective doc is updated with learnings from the new defect specs
    And the 3 existing learnings are preserved
    And the "Last Updated" date is refreshed

  Scenario: Retrospective doc removes outdated learnings
    Given a ".claude/steering/retrospective.md" exists with learnings
    And one of the source defect specs has been deleted since the last run
    When the user runs "/running-retrospectives"
    Then the learning from the deleted defect spec is removed
    And learnings from still-existing defect specs are preserved

  # --- Error Handling ---

  Scenario: Broken Related Spec link is handled gracefully
    Given a defect spec has a "Related Spec:" link to ".claude/specs/nonexistent-feature/"
    And the referenced spec directory does not exist
    When the user runs "/running-retrospectives"
    Then the skill warns about the broken link
    And the defect spec is skipped
    And other eligible defect specs are still processed

  Scenario: Sparse defect spec produces best-effort learning
    Given a defect spec has a "Related Spec:" link and minimal content
    When the user runs "/running-retrospectives"
    Then the skill produces a best-effort learning from available information
    And the learning is flagged as low-confidence if insufficient detail exists


Feature: Retrospective State Tracking and Deduplication
  As a spec author (human or OpenClaw automation agent)
  I want the retrospectives skill to track analyzed defect specs and skip unchanged ones
  So that retrospective runs are efficient and never produce duplicate learnings

  # --- Happy Path ---

  Scenario: State file created on first run
    Given no ".claude/steering/retrospective-state.json" exists
    And defect specs with Related Spec links exist in ".claude/specs/"
    When the retrospectives skill completes a run
    Then a "retrospective-state.json" is written to ".claude/steering/"
    And it contains an entry for each analyzed defect spec
    And each entry includes the spec's file path, content hash, and analysis date

  Scenario: Unchanged specs are skipped on subsequent runs
    Given a "retrospective-state.json" exists with hashes from a previous run
    And 3 defect specs have not changed since that run
    And 2 defect specs have been modified
    When the retrospectives skill runs again
    Then the 3 unchanged defect specs are not re-analyzed
    And their existing learnings are preserved in the output
    And only the 2 modified specs are re-analyzed

  Scenario: Modified specs are re-analyzed
    Given a "retrospective-state.json" exists with a hash for a defect spec
    And that defect spec's content has changed since the last run
    When the retrospectives skill runs again
    Then the modified spec is re-analyzed
    And its hash is updated in the state file
    And its learnings reflect the updated content

  Scenario: New specs are analyzed and added to state
    Given a "retrospective-state.json" exists from a previous run with 5 entries
    And a new defect spec has been added to ".claude/specs/"
    When the retrospectives skill runs again
    Then the new spec is analyzed
    And a new entry is added to the state file
    And the state file now contains 6 entries

  # --- Cleanup ---

  Scenario: Deleted specs are cleaned up from state
    Given a "retrospective-state.json" references a defect spec at ".claude/specs/99-old-bug/"
    And that spec directory no longer exists on disk
    When the retrospectives skill runs again
    Then the entry for ".claude/specs/99-old-bug/" is removed from the state file
    And learnings sourced solely from that deleted spec are removed from the retrospective

  # --- Deduplication ---

  Scenario: Near-duplicate learnings are merged
    Given the skill has completed analysis of new and modified specs
    And carried-forward learnings from unchanged specs are included
    When the aggregation pass runs on the combined set
    Then no two learnings in the output have overlapping core patterns
    And near-duplicate learnings are merged with combined evidence references

  # --- State File Format ---

  Scenario: State file is valid JSON with required fields
    Given the retrospectives skill completes successfully
    When "retrospective-state.json" is written
    Then the file contains valid JSON
    And the JSON has a "version" field set to 1
    And the JSON has a "specs" object mapping paths to entries
    And each entry has a "hash" string and a "lastAnalyzed" date string

  # --- Error Handling ---

  Scenario: Graceful degradation with malformed state file
    Given a "retrospective-state.json" exists but contains invalid JSON
    When the retrospectives skill runs
    Then a warning is logged about the corrupt state file
    And a full re-analysis is performed as if no state file exists
    And a valid state file is written upon completion

  # --- Output Summary ---

  Scenario: Output summary distinguishes new vs carried-forward learnings
    Given the skill completes with both newly analyzed and unchanged specs
    When the output summary is displayed
    Then the summary shows the total defect spec count
    And the summary shows the breakdown of new, modified, skipped, and removed specs
    And the summary shows the count of new learnings vs carried-forward learnings

  # --- Hash Computation ---

  Scenario: Content hash is computed before analysis begins
    Given a defect spec is eligible for analysis
    When the skill processes the spec
    Then a SHA-256 hash is computed from the spec's requirements.md content
    And this hash is compared against the stored hash before deciding whether to analyze
