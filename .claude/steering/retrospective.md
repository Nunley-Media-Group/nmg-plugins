# Spec Retrospective

**Last Updated**: 2026-02-22
**Defect Specs Analyzed**: 18
**Learnings Generated**: 16

---

## How to Use This Document

This document is automatically generated by `/running-retrospectives` and read by
`/writing-specs` during Phase 1 (SPECIFY). When writing new feature specs, apply
these transferable patterns to new feature contexts — adapt each learning to the
current feature's domain rather than applying it literally.

---

## Missing Acceptance Criteria

Defects caused by scenarios that the original feature spec did not cover at all.

| Learning | Recommendation | Evidence (defect specs) |
|----------|---------------|------------------------|
| When specifying features that create temporary artifacts in project directories (flag files, lock files, state files), the full artifact lifecycle is often unspecified — creation is covered but persistence prevention and cleanup are not | Include ACs for the complete artifact lifecycle: creation conditions, persistence prevention in version control (e.g., gitignore entries), and cleanup across all exit paths (normal completion, error, signal, crash) | .claude/specs/bug-fix-auto-mode-cleanup-on-exit/, .claude/specs/bug-fix-sdlc-runner-auto-mode-gitignore/ |
| When specifying multi-step automated workflows, steps that interact with external systems are often specified as "check status" without requiring the step to achieve a goal | Include ACs that distinguish between observational steps (check/report) and remediation steps (diagnose and fix), ensuring each step's success criteria require achieving the intended outcome, not just running without error | .claude/specs/bug-fix-monitorci-step8/ |
| When specifying features that consume configuration or context documents at multiple processing stages, the spec often references "context documents" generically without enumerating which documents are read at which stage | Include ACs that enumerate which context sources (config files, steering docs, state files) are read at each processing step, rather than referencing them as a generic collection | .claude/specs/bug-fix-creating-issues-steering-docs/ |
| When specifying features that produce synthesized output from multiple inputs (aggregated reports, summaries, analyses), the spec often describes the desired output without specifying the required abstraction level or aggregation behavior | Include ACs for the required abstraction level of generated output (how generic vs. specific) and whether similar inputs should be merged into consolidated entries or kept separate | .claude/specs/bug-fix-retrospective-learnings-transferability/ |
| When specifying features that explicitly exclude integration with a system-wide behavior mode (e.g., headless mode, admin mode), stating the exclusion in "Out of Scope" is insufficient because the agent may still detect and honor the mode | Include a defensive AC stating the feature must actively ignore the excluded mode, ensuring the interactive/default behavior is preserved regardless of mode signals in the environment | .claude/specs/bug-fix-migrating-projects-auto-mode/ |
| When specifying features that depend on optional external integrations (CI pipelines, webhooks, monitoring services), the spec often assumes the integration is always present | Include ACs for the "integration absent" scenario — graceful degradation or automatic skip when the external integration is not configured for the target environment | .claude/specs/bug-fix-sdlc-runner-infinite-retry-no-ci/ |
| When specifying features that manage system resources (processes, files, connections) via pattern matching, the spec often defines the matching criteria without constraining the operation's scope or ownership | Include ACs that define both the scope of the operation (e.g., entire process trees vs. individual processes) and ownership constraints (e.g., only resources spawned by this system, not unrelated matches) | .claude/specs/bug-fix-sdlc-runner-process-tree-cleanup/ |
| When specifying features that include optional cross-reference fields linking artifacts to related artifacts, the spec often defines the field's structure but provides no mechanism for discovering which artifact to link to | Include ACs for the discovery mechanism that populates cross-reference fields — specify what search strategy is used (keyword matching, path analysis, identifier lookup) rather than relying on agent intuition | .claude/specs/bug-fix-writing-specs-defect-related-spec-search/ |
| When specifying features that filter or select from hierarchical data (categories containing items, milestones containing issues), the spec often defines the selection UX without specifying how the candidate set is retrieved and pre-filtered | Include ACs specifying the data retrieval strategy for selection interfaces, including pre-filtering to viable options using metadata (e.g., counts, status flags) rather than iterative probing | .claude/specs/bug-fix-starting-issues-milestone-selection/ |
| When specifying features that apply templates or configuration standards to diverse target projects, the spec often assumes all template sections are universally applicable | Include ACs for relevance filtering based on target project characteristics (codebase analysis, config file detection, directory structure), and for persisting user decisions about irrelevant sections across runs | .claude/specs/bug-fix-migrating-projects-irrelevant-sections/ |

---

## Undertested Boundaries

Defects caused by boundary conditions the original feature spec addressed
insufficiently.

| Learning | Recommendation | Evidence (defect specs) |
|----------|---------------|------------------------|
| When specifying features that delegate work to subprocesses or external tools, defining success as "exit code 0" leaves a gap where the subprocess may exit cleanly despite not achieving its goal — the spec tests the "success reported" boundary but not the "success verified" boundary | Include ACs requiring post-step artifact verification (expected files exist, expected state changes occurred) and structured output metadata validation (subtypes, error flags, permission denials) in addition to exit code checks | .claude/specs/bug-fix-silent-commitpush-failure/, .claude/specs/bug-detect-soft-failures-runner-tests/ |
| When specifying orchestration features that manage subprocesses, external API calls, and persistent state, the spec often covers the happy-path flow and basic retry/escalation without specifying defensive behaviors at each interaction boundary | Include ACs for signal propagation to child processes, non-blocking retry backoff for external API calls, safe handling of user-derived strings passed to shell commands, and error recovery for stateful transitions (e.g., dirty working tree during checkout) | .claude/specs/bug-sdlc-runner-edge-case-fixes/ |
| When specifying features where critical operations are performed by AI agents following prompt-based instructions, the spec often treats the operation as deterministic when agent compliance with complex multi-step instructions is probabilistic | Include ACs for postcondition verification of the critical operation's output — a deterministic check that the expected result was actually produced, with retry on failure — rather than relying solely on the agent completing its instructions | .claude/specs/bug-fix-inconsistent-version-bumping/ |
| When specifying features that process sequential independent work items in a loop, the spec often covers single-iteration behavior without specifying inter-iteration isolation | Include ACs for state isolation between iterations (clean working directory, reset of extracted identifiers) and reliable identification of the current work item from ground-truth sources (e.g., branch name) rather than parsing unstructured output from previous steps | .claude/specs/bug-fix-sdlc-runner-cross-cycle-state-contamination/ |

---

## Domain-Specific Gaps

Defects caused by domain knowledge the original feature spec failed to capture.

| Learning | Recommendation | Evidence (defect specs) |
|----------|---------------|------------------------|
| When specifying features that discover or parse structured content within markdown file hierarchies, the spec often references field names without accounting for markdown formatting variants or directory depth in search patterns | Specify the exact formatting variants target fields may use (e.g., bold `**Field**:` vs plain `Field:`), and ensure file discovery patterns account for the actual directory structure depth (e.g., `**/file.md` vs `*/file.md` for nested directories) | .claude/specs/bug-fix-retrospectives-severity-grep-pattern/, .claude/specs/bug-fix-retrospective-defect-spec-discovery/ |
| When specifying features that traverse cross-reference links between artifacts of different types, the spec often assumes links always point directly to the expected target type without considering that links may chain through intermediate artifacts of the same source type | Include ACs for chain resolution (following link-to-link traversal until reaching the expected target type), circular reference detection (preventing infinite traversal), and validation that terminal links point to the expected artifact type | .claude/specs/bug-fix-retrospective-defect-spec-discovery/ |
